using System;
using System.Management;
using System.Security.Cryptography;
using System.Text;

namespace PyClickerRecorder
{
    public static class LicenseManager
    {
        // IMPORTANT: This public key MUST be replaced with the one generated by the KeyGenerator tool.
        private const string PublicKeyBase64 = "MIIBCgKCAQEAxZpYBYH4tiNSESbyJpHQgjFX8Yu0SUsF+mk85offnbFiHhwjr6vA3HhZ3MMWqmxKsfwpqrf22ZixSIVWcI968bkTIKpq8vkEdEBwp3cqgYFF4AweuAUHeSMFXKEd3Uow+MGC/n45BidnX6gUhne8L9yQFq9DKXMZ0PzUHVbTJSbREkwTlJ9R/O8AlQbYdLIANizAxKBH/ezkSvJ1v0fRP1Qg6mcIvlPU/7ikzMPbE4OOPCJ2xsdcQAdsZxjBMMTrI4BKk7YZXeBS2zwYnuMqyzpvfG7v8sgN6zhHFbeHAJkYm3G+YO/Cm6IocxK7ISBLzq4ygoF5jHK9e+qDzlUkyQIDAQAB";

        private static string GetRawMachineId()
        {
            try
            {
                var mbs = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BaseBoard");
                ManagementObjectCollection mbsList = mbs.Get();
                string id = "";
                foreach (ManagementObject mo in mbsList)
                {
                    id = mo["SerialNumber"]?.ToString() ?? "";
                    if (!string.IsNullOrEmpty(id))
                    {
                        break;
                    }
                }
                return string.IsNullOrEmpty(id) ? "DefaultMachineId" : id;
            }
            catch (Exception)
            {
                return "CouldNotRetrieveMachineId";
            }
        }

        public static string GetEncryptedMachineId()
        {
            try
            {
                string machineId = GetRawMachineId();
                using (var rsa = RSA.Create())
                {
                    byte[] publicKeyBytes = Convert.FromBase64String(PublicKeyBase64);
                    rsa.ImportRSAPublicKey(publicKeyBytes, out _);
                    
                    byte[] machineIdBytes = Encoding.UTF8.GetBytes(machineId);
                    byte[] encryptedBytes = rsa.Encrypt(machineIdBytes, RSAEncryptionPadding.OaepSHA256);
                    
                    return Convert.ToBase64String(encryptedBytes);
                }
            }
            catch (Exception ex)
            {
                // Return a clear error message if something goes wrong, e.g., invalid public key
                return $"Error generating ID: {ex.Message}";
            }
        }

        public static bool IsLicenseValid(string licenseKey)
        {
            if (string.IsNullOrWhiteSpace(licenseKey))
            {
                return false;
            }

            try
            {
                string machineId = GetRawMachineId();
                byte[] machineIdBytes = Encoding.UTF8.GetBytes(machineId);
                byte[] signatureBytes = Convert.FromBase64String(licenseKey);

                using (var rsa = RSA.Create())
                {
                    byte[] publicKeyBytes = Convert.FromBase64String(PublicKeyBase64);
                    rsa.ImportRSAPublicKey(publicKeyBytes, out _);

                    return rsa.VerifyData(machineIdBytes, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
                }
            }
            catch
            {
                // Catches errors from invalid Base64 string, cryptographic issues, etc.
                return false;
            }
        }
    }
}
